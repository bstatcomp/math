#ifndef STAN_MATH_GPU_MATRIX_INVERSE_KERNELS_HPP
#define STAN_MATH_GPU_MATRIX_INVERSE_KERNELS_HPP

#include <string>

/**
 *  @file stan/math/gpu/kernels/inverse_gpu_kernels.hpp
 *  @brief Kernel sources for matrix inverse on the gpu:
 *    inverse of the lower triangular matrix
 */

namespace stan {
  namespace math {
	
	std::string lower_tri_inverse_step1_kernel = 
	"#ifdef cl_khr_fp64 \n"
	"	#pragma OPENCL EXTENSION cl_khr_fp64 : enable \n"
	"#elif defined(cl_amd_fp64) \n"
	"	#pragma OPENCL EXTENSION cl_amd_fp64 : enable \n"
	"#else \n"
	"	#error \"Double not supported by OpenCL implementation.\" \n"
	"#endif \n"
	" \n"
	"#define A(i,j) A[j*rows+i] \n"
	"#define V(i,j) V[offset+j*(part_size_fixed+1)+i]  \n"
	"__kernel void lower_tri_inverse_step1( \n"
	"				__global double* A, \n"
	"				__global double* V, \n"
	"				int remainder, \n"
	"				int part_size_fixed, \n"
	"				int rows) { \n"
	" int indeks = get_global_id(0); \n"
	"  int i = indeks*part_size_fixed; \n"
	" int part_size; \n"
	"  double faktor; \n"
	"  if ( indeks < remainder ) { \n"
	"	i += indeks; \n"
	"	part_size = part_size_fixed+1; \n"
	" } else { \n"
	"	i += remainder; \n"
	"	part_size = part_size_fixed; \n"
	" } \n"
	"  int offset = indeks*(part_size_fixed+1)*(part_size_fixed+1); \n"
	"  for (int p = 0; p < part_size; p++) { \n"
	"	for (int r = 0; r < part_size; r++) { \n"
	"	  if ( p == r ) \n"
	"		V(p,r) = 1; \n"
	"	  else \n"
	"		V(p,r) = 0; \n"
	"	} \n"
	" } \n"
	"  for (unsigned int ii = 0; ii < part_size; ii++) { \n"
	"	if ( ii > 0 ) { \n"
	"	  for (unsigned int j = ii; j < part_size; j++) { \n"
	"		faktor = A((j+i),(i+ii-1)); \n"
	"		for (unsigned int k = 0; k < part_size; k++) { \n"
	"		  V(j,k) -= faktor*V((ii-1),k); \n"
	"		} \n"
	"	  } \n"
	"	} \n"
	"	faktor = A((ii+i),(ii+i)); \n"
	"	for (unsigned int k = 0; k < part_size; k++) { \n"
	"	  V(ii,k) /= faktor; \n"
	"	} \n"
	" } \n"
	"  for (int p = 0; p < part_size; p++) { \n"
	"	for (int r=0; r < part_size; r++) { \n"
	"	  A((p+i),(i+r)) = V(p,r); \n"
	"	} \n"
	" } \n"
	"} \n";

	std::string lower_tri_inverse_step2_kernel = 
	"#define temp(i,j) temp[(n/2)*(sizeM)*(sizeM)+j*part_size2+i] \n"
	" \n"
	"#define WPT 4 \n"
	"#define RTS TS2/WPT \n"
	"__kernel void lower_tri_inverse_step2( \n"
	"				__global double* A, \n"
	"				__global int* sizes, \n"
	"				__global double* temp, \n"
	"				int repeat, \n"
	"				int remainder, \n"
	"				int part_size_fixed, \n"
	"				int rows) { \n"
	"int n = get_global_id(2)*2; \n"
	" double sum = 0; \n"
	" int part_size1 = 0, part_size2 = 0; \n"
	" int offset_i, offset_j; \n"
	" for (int r = n*repeat; r < (n+1)*repeat; r++) \n"
	"  part_size1 += sizes[r]; \n"
	" for (int r = (n+1)*repeat; r < (n+2)*repeat; r++) \n"
	"  part_size2 += sizes[r]; \n"
	" int sizeM = repeat*(part_size_fixed+1); \n"
	" offset_i = (n+1)*repeat*part_size_fixed; \n"
	" offset_j = n*repeat*part_size_fixed; \n"
	" if ( ((n+1)*repeat) <= remainder ) \n"
	"  offset_i += (n+1)*repeat; \n"
	" else \n"
	"  offset_i += remainder; \n"
	" if ( (n*repeat) <= remainder ) \n"
	"  offset_j += n*repeat; \n"
	" else \n"
	"  offset_j += remainder; \n"
	" const int row = get_local_id(0); \n"
	" const int col = get_local_id(1); \n"
	"  const int i = TS2*get_group_id(0) + row; \n"
	"  const int j = TS2*get_group_id(1) + col; \n"
	"  __local double Asub[TS2][TS2]; \n"
	"  __local double Bsub[TS2][TS2]; \n"
	"  double acc[WPT]; \n"
	"  for (int w = 0; w < WPT; w++) { \n"
	"		  acc[w] = 0.0; \n"
	"  } \n"
	" \n"
	" const int numTiles = (part_size2+TS2-1)/TS2; \n"
	" sum = 0; \n"
	" for (int t = 0; t < numTiles; t++) { \n"
	"  for (int w = 0; w < WPT; w++) { \n"
	"   const int tiledRow = TS2*t + row; \n"
	"   const int tiledCol = TS2*t + col; \n"
	" \n"
	"   if ( i < part_size2 && (tiledCol+w*RTS) < part_size1 && \n"
	"	  (tiledCol+offset_j+part_size1+w*RTS) < rows  && (i+offset_i) < rows ) { \n"
	"	Asub[col+w*RTS][row] = \n"
	"	  A((i+offset_i),(tiledCol+offset_j+part_size1+w*RTS)); \n"
	"  } else { \n"
	"	Asub[col+w*RTS][row] = 0.0; \n"
	"   } \n"
	" \n"
	"   if ( (j+w*RTS) < part_size1 && tiledRow < part_size2 && \n"
	"		(tiledRow+offset_i) < rows && (j+offset_j+w*RTS) < rows ) { \n"
	"	Bsub[col+w*RTS][row] = A((tiledRow+offset_i),(j+offset_j+w*RTS)); \n"
	"   } else { \n"
	"	Bsub[col+w*RTS][row] = 0.0; \n"
	"  } \n"
	"  } \n"
	" \n"
	"  barrier(CLK_LOCAL_MEM_FENCE); \n"
	" \n"
	"  for (int k = 0; k < TS2; k++) { \n"
	"   for (int w = 0; w < WPT; w++) { \n"
	"	acc[w] += Asub[k][row]*Bsub[col+w*RTS][k]; \n"
	"   } \n"
	"  } \n"
	"  barrier(CLK_LOCAL_MEM_FENCE); \n"
	" } \n"
	" \n"
	" for (int w = 0; w < WPT; w++) { \n"
	"  if ( i < part_size2 && (j+w*RTS) < part_size1 && \n"
	"	   i < sizeM && (j+w*RTS) < sizeM ) { \n"
	"   temp(i,(j+w*RTS)) = acc[w]; \n"
	"  } \n"
	" } \n"
	"} \n";

	std::string lower_tri_inverse_step3_kernel = 
	"__kernel void lower_tri_inverse_step3(	\n"
	"				__global double* A,	\n"
	"				__global int* sizes,	\n"
	"				__global double* temp,	\n"
	"				int repeat,	\n"
	"				int remainder,	\n"
	"				int part_size_fixed,	\n"
	"				int rows) {	\n"
	" int n = get_global_id(2)*2;	\n"
	" double sum = 0;	\n"
	" int part_size1 = 0, part_size2 = 0;	\n"
	" int offset_i, offset_j;	\n"
	" for (int r = n*repeat; r < (n+1)*repeat; r++)	\n"
	"  part_size1 += sizes[r];	\n"
	" for (int r = (n+1)*repeat; r < (n+2)*repeat; r++)	\n"
	"  part_size2 += sizes[r];	\n"
	"	\n"
	" int sizeM = repeat*(part_size_fixed+1);	\n"
	" offset_i = (n+1)*repeat*part_size_fixed;	\n"
	" offset_j = n*repeat*part_size_fixed;	\n"
	" if ( ((n+1)*repeat) <= remainder )	\n"
	"  offset_i += (n+1)*repeat;	\n"
	" else	\n"
	"  offset_i += remainder;	\n"
	"	\n"
	" if ( (n*repeat) <= remainder )	\n"
	"  offset_j += n*repeat;	\n"
	" else	\n"
	"  offset_j += remainder;	\n"
	"	\n"
	" const int row = get_local_id(0);	\n"
	" const int col = get_local_id(1);	\n"
	" const int i = TS2*get_group_id(0) + row;	\n"
	" const int j = TS2*get_group_id(1) + col;	\n"
	"	\n"
	"  __local double Asub[TS2][TS2];	\n"
	"  __local double Bsub[TS2][TS2];	\n"
	"	\n"
	" double acc[WPT];	\n"
	" for (int w = 0; w < WPT; w++) {	\n"
	"	  acc[w] = 0.0f;	\n"
	" }	\n"
	"	\n"
	" const int numTiles = (part_size1+TS2-1)/TS2;	\n"
	"	\n"
	" sum = 0;	\n"
	" for (int t = 0; t < numTiles; t++) {	\n"
	"  for (int w = 0; w < WPT; w++) {	\n"
	"   const int tiledRow = TS2*t + row;	\n"
	"   const int tiledCol = TS2*t + col;	\n"
	"   if ( i < part_size2 && (tiledCol+w*RTS) < part_size1 &&	\n"
	"		i < sizeM && (tiledCol+w*RTS) < sizeM ) {	\n"
	"	Asub[col+w*RTS][row] =	\n"
	"		temp(i,(tiledCol+w*RTS));	\n"
	"   } else {	\n"
	"	Asub[col+w*RTS][row] = 0.0;	\n"
	"   }	\n"
	"   if ( (j+w*RTS) < part_size1 && (j+offset_j+w*RTS) < rows &&	\n"
	"		(tiledRow+offset_i-part_size1) < rows ) {	\n"
	"	Bsub[col+w*RTS][row] =	\n"
	"		A((tiledRow+offset_i-part_size1),(j+offset_j+w*RTS));	\n"
	"   } else {	\n"
	"	Bsub[col+w*RTS][row] = 0.0;	\n"
	"   }	\n"
	"  }	\n"
	"  barrier(CLK_LOCAL_MEM_FENCE);	\n"
	"	\n"
	"  for (int k = 0; k < TS2; k++) {	\n"
	"   for (int w = 0; w < WPT; w++) {	\n"
	"	acc[w] += Asub[k][row]*Bsub[col+w*RTS][k];	\n"
	"   }	\n"
	"  }	\n"
	"  barrier(CLK_LOCAL_MEM_FENCE);	\n"
	" }	\n"
	" for (int w = 0; w < WPT; w++) {	\n"
	"  if ( i < part_size2 && (j+w*RTS) < part_size1 &&	\n"
	"	  (i+offset_i) < rows && (j+offset_j+w*RTS) < rows ) {	\n"
	"   A((i+offset_i),(j+offset_j+w*RTS)) = -acc[w];	\n"
	"  }	\n"
	" }	\n"
	"}	\n";
  }
}
#endif