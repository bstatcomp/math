#ifndef STAN_MATH_GPU_MULTIPLY_MATRIX_KERNELS_HPP
#define STAN_MATH_GPU_MULTIPLY_MATRIX_KERNELS_HPP

#include <string>

/**
 *  @file stan/math/gpu/kernels/multiply_matrix_kernels.hpp
 *  @brief Kernel sources for matrix multiplication on the gpu:
 *    multiply with the diagonal, multiply with a scalar,
 *    and 3 variations of GEMM: normal, self transposed and
 *    multiplication of a lower triangular matrix
 */

namespace stan {
  namespace math {

  std::string scalar_mul_diagonal_kernel =
  "#ifdef cl_khr_fp64 \n"
  "  #pragma OPENCL EXTENSION cl_khr_fp64 : enable \n"
  "#elif defined(cl_amd_fp64) \n"
  "  #pragma OPENCL EXTENSION cl_amd_fp64 : enable \n"
  "#else \n"
  "  #error \"Double not supported by OpenCL implementation.\" \n"
  "#endif \n"
  " \n"
  "#define a(i,j)  a[j*rows+i] \n"
  "#define b(i,j)  b[j*rows+i] \n"
  "#define c(i,j)  c[j*rows+i] \n"
  " \n"
  "__kernel void scalar_mul_diagonal( \n"
  "      __global double *a, \n"
  "      double scalar, \n"
  "      unsigned int rows, \n"
  "      unsigned int cols) { \n"
  "  int i = get_global_id(0); \n"
  "  if ( i < rows && i < cols ) { \n"
  "   a(i,i) *= scalar; \n"
  "  } \n"
  "} \n";

  std::string scalar_mul_kernel =
  "__kernel void scalar_mul( \n"
  "      __global double *a, \n"
  "      __global double *b, \n"
  "      double scalar, \n"
  "      unsigned int rows, \n"
  "      unsigned int cols) { \n"
  "  int i = get_global_id(0); \n"
  "  int j = get_global_id(1); \n"
  "  if ( i < rows && j < cols ) { \n"
  "   a(i,j) = b(i,j)*scalar; \n"
  "  } \n"
  "} \n";

  std::string basic_multiply_kernel =
  "#define A(i,j)  A[j*M+i] \n"
  "#define B(i,j)  B[j*K+i] \n"
  "#define C(i,j)  C[j*M+i] \n"
  " \n"
  "#define WPT 4 \n"
  "#define RTS TS/WPT \n"
  "__kernel void basic_multiply(const int M, const int N, const int K, \n"
  "            const __global double* A, \n"
  "            const __global double* B, \n"
  "            __global double* C) { \n"
  "     \n"
  "  const int row = get_local_id(0); \n"
  "  const int col = get_local_id(1); \n"
  "  const int i = TS*get_group_id(0) + row; \n"
  "  const int j = TS*get_group_id(1) + col; \n"
  "   \n"
  "  __local double Asub[TS][TS]; \n"
  "  __local double Bsub[TS][TS]; \n"
  " \n"
  "  double acc[WPT]; \n"
  "  for (int w=0; w<WPT; w++) { \n"
  "    acc[w] = 0.0; \n"
  "  } \n"
  "   \n"
  "  const int numTiles = (K+TS-1)/TS; \n"
  "  for (int t=0; t<numTiles; t++) { \n"
  "    for (int w=0; w<WPT; w++) { \n"
  "      const int tiled_i = TS*t + row; \n"
  "      const int tiled_j = TS*t + col; \n"
  "      if ( i < M && (tiled_j + w*RTS) < K ) { \n"
  "        Asub[col + w*RTS][row] = A[(tiled_j + w*RTS)*M + i]; \n"
  "      }else{ \n"
  "        Asub[col + w*RTS][row] = 0.0; \n"
  "      } \n"
  "      if ( tiled_i < K && (j + w*RTS) < N ) { \n"
  "        Bsub[col + w*RTS][row] = B[(j + w*RTS)*K + tiled_i]; \n"
  "      }else{ \n"
  "        Bsub[col + w*RTS][row] = 0.0; \n"
  "      } \n"
  "    } \n"
  "     \n"
  "     \n"
  "    barrier(CLK_LOCAL_MEM_FENCE); \n"
  " \n"
  "    for (int k=0; k<TS; k++) { \n"
  "      for (int w=0; w<WPT; w++) { \n"
  "        acc[w] += Asub[k][row] * Bsub[col + w*RTS][k]; \n"
  "      } \n"
  "    } \n"
  " \n"
  "    barrier(CLK_LOCAL_MEM_FENCE); \n"
  "  } \n"
  "  \n"
  "  for (int w=0; w<WPT; w++) { \n"
  "    if ( (j + w*RTS) < N && i < M ) { \n"
  "    C[(j + w*RTS)*M + i] = acc[w]; \n"
  "    } \n"
  "  } \n"
  "} \n";

  std::string multiply_self_transposed_kernel =
  "#define WPT1 4 \n"
  "#define RTS1 TS1/WPT1 \n"
  "__kernel void multiply_self_transposed(const int M, \n"
  "            const int N, const int K, \n"
  "            const __global double* A, \n"
  "            const __global double* B, \n"
  "            __global double* C) { \n"
  "   \n"
  "  const int row = get_local_id(0);  \n"
  "  const int col = get_local_id(1);  \n"
  "  const int i = TS1*get_group_id(0) + row;  \n"
  "  const int j = TS1*get_group_id(1) + col;  \n"
  "  const int jMin = TS1*get_group_id(1); \n"
  "  const int iMax = TS1*get_group_id(0)  + get_local_size(0); \n"
  "   \n"
  "  __local double Asub[TS1][TS1]; \n"
  "  __local double Bsub[TS1][TS1]; \n"
  " \n"
  "  double acc[WPT1]; \n"
  "  for (int w=0; w<WPT1; w++) { \n"
  "    acc[w] = 0.0; \n"
  "  } \n"
  "   \n"
  "  const int numTiles = (K+TS1-1)/TS1; \n"
  "  for (int t=0; t<numTiles; t++) { \n"
  "    if(jMin <= iMax){ \n"
  "     \n"
  "    for (int w=0; w<WPT1; w++) { \n"
  "      const int tiled_i = TS1*t + row; \n"
  "      const int tiled_j = TS1*t + col; \n"
  "      if ( i < M && (tiled_j + w*RTS1) < K ) { \n"
  "        Asub[col + w*RTS1][row] = A[(tiled_j + w*RTS1)*M + i]; \n"
  "      }else{ \n"
  "        Asub[col + w*RTS1][row] = 0.0; \n"
  "      } \n"
  "      if ( tiled_i < K && (j + w*RTS1) < N ) { \n"
  "        Bsub[col + w*RTS1][row] = B[(j + w*RTS1)*K + tiled_i]; \n"
  "      }else{ \n"
  "        Bsub[col + w*RTS1][row] = 0.0; \n"
  "      } \n"
  "    } \n"
  "  } \n"
  "     \n"
  "    barrier(CLK_LOCAL_MEM_FENCE); \n"
  " \n"
  "    for (int k=0; k<TS1; k++) { \n"
  "      for (int w=0; w<WPT1; w++) { \n"
  "        if((j + w*RTS1)<=i){ \n"
  "        acc[w] += Asub[k][row] * Bsub[col + w*RTS1][k]; \n"
  "        } \n"
  "      } \n"
  "    } \n"
  "   \n"
  "    barrier(CLK_LOCAL_MEM_FENCE); \n"
  "  } \n"
  "  \n"
  "  for (int w=0; w<WPT1; w++) { \n"
  "    if ( (j + w*RTS1) < N && i < M  && (j + w*RTS1)<=i ) { \n"
  "    C[(j + w*RTS1)*M + i] = acc[w]; \n"
  "    C[i*M + (j + w*RTS1)] = acc[w]; \n"
  "    } \n"
  "  } \n"
  "} \n";

  std::string multiply_lower_triangular_kernel =
  "#define WPT1 4 \n"
  "#define RTS1 TS1/WPT1 \n"
  "__kernel void multiply_lower_triangular( \n"
  "            const int M, \n"
  "            const int N, \n"
  "            const int K, \n"
  "            const __global double* A, \n"
  "            const __global double* B, \n"
  "            __global double* C) { \n"
  "   \n"
  "  const int row = get_local_id(0);  \n"
  "  const int col = get_local_id(1);  \n"
  "  const int i = TS1*get_group_id(0) + row;  \n"
  "  const int j = TS1*get_group_id(1) + col;  \n"
  "  const int jMin = TS1*get_group_id(1); \n"
  "  const int iMax = TS1*get_group_id(0)  + get_local_size(0); \n"
  "   \n"
  "  __local double Asub[TS1][TS1]; \n"
  "  __local double Bsub[TS1][TS1]; \n"
  " \n"
  "  double acc[WPT1]; \n"
  "  for (int w=0; w<WPT1; w++) { \n"
  "    acc[w] = 0.0; \n"
  "  } \n"
  "   \n"
  "  const int numTiles = (K+TS1-1)/TS1; \n"
  "  for (int t=0; t<numTiles; t++) { \n"
  "    if(jMin <= iMax){ \n"
  "      for (int w=0; w<WPT1; w++) { \n"
  "        const int tiled_i = TS1*t + row; \n"
  "        const int tiled_j = TS1*t + col; \n"
  "        if ( i < M && (tiled_j + w*RTS1) < K ) { \n"
  "        Asub[col + w*RTS1][row] = A[(tiled_j + w*RTS1)*M + i]; \n"
  "        }else{ \n"
  "        Asub[col + w*RTS1][row] = 0.0; \n"
  "        } \n"
  "        if ( tiled_i < K && (j + w*RTS1) < N ) { \n"
  "        Bsub[col + w*RTS1][row] = B[(j + w*RTS1)*K + tiled_i]; \n"
  "        }else{ \n"
  "        Bsub[col + w*RTS1][row] = 0.0; \n"
  "        } \n"
  "      } \n"
  "    } \n"
  "    barrier(CLK_LOCAL_MEM_FENCE); \n"
  "    for (int k=0; k<TS1; k++) { \n"
  "      for (int w=0; w<WPT1; w++) { \n"
  "        if((j + w*RTS1)<=i){ \n"
  "        if((k+t*TS1)>=i) \n"
  "          acc[w] += Asub[k][row] * Bsub[col + w*RTS1][k]; \n"
  "        } \n"
  "      } \n"
  "    } \n"
  "    barrier(CLK_LOCAL_MEM_FENCE); \n"
  "  } \n"
  "  \n"
  "  for (int w=0; w<WPT1; w++) { \n"
  "    if ( (j + w*RTS1) < N && i < M  && (j + w*RTS1)<=i ) { \n"
  "    C[(j + w*RTS1)*M + i] = acc[w]; \n"
  "    C[i*M + (j + w*RTS1)] = acc[w]; \n"
  "    } \n"
  "  } \n"
  "} \n";

  }
}
#endif
